// src/app/api/dashboardPagesAPI/add-dealers/route.ts
import { NextResponse, NextRequest } from 'next/server';
import { getTokenClaims } from '@workos-inc/authkit-nextjs';
import prisma from '@/lib/prisma'; // Ensure this path is correct for your Prisma client
import { z } from 'zod';

// Schema for the data returned by the GET endpoint (full dealer record)
// This schema includes 'id', 'createdAt', 'updatedAt'
const getDealerResponseSchema = z.object({
    id: z.string().uuid(), // Expecting a UUID string
    name: z.string().min(1, "Dealer name is required."),
    type: z.string().min(1, "Dealer type is required."), // Flexible string for existing data
    region: z.string().min(1, "Region is required."),     // Flexible string for existing data
    area: z.string().min(1, "Area is required."),         // Flexible string for existing data
    phoneNo: z.string().min(1, "Phone number is required.").max(20, "Phone number is too long."),
    address: z.string().min(1, "Address is required.").max(500, "Address is too long."),
    totalPotential: z.number().positive("Total potential must be a positive number."),
    bestPotential: z.number().positive("Best potential must be a positive number."),
    brandSelling: z.array(z.string()).min(1, "At least one brand must be selected."),
    feedbacks: z.string().min(1, "Feedbacks are required.").max(500, "Feedbacks are too long."),
    remarks: z.string().nullable().optional(), // Optional field
    createdAt: z.string(), // Expecting ISO string
    updatedAt: z.string(), // Expecting ISO string
});

// Schema for the POST request body (data sent from frontend to create a new dealer)
// This schema does NOT include 'id', 'createdAt', 'updatedAt' as they are generated by DB
const postDealerSchema = z.object({
    name: z.string().min(1, "Dealer name is required."),
    type: z.string(),
    region: z.string(),
    area: z.string(),
    phoneNo: z.string().min(1, "Phone number is required.").max(20, "Phone number is too long."),
    address: z.string().min(1, "Address is required.").max(500, "Address is too long."),
    totalPotential: z.number().positive("Total potential must be a positive number."),
    bestPotential: z.number().positive("Best potential must be a positive number."),
    brandSelling: z.array(z.string()).min(1, "At least one brand must be selected."),
    feedbacks: z.string().min(1, "Feedbacks are required.").max(500, "Feedbacks are too long."),
    remarks: z.string().nullable().optional(), // Optional field
});

const allowedRoles = ['senior-executive', 'executive', 'junior-executive'];

export async function POST(request: NextRequest) {
    try {
        const claims = await getTokenClaims();

        // 1. Authentication Check
        if (!claims || !claims.sub) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        // 2. Fetch Current User to get their ID and role
        const currentUser = await prisma.user.findUnique({
            where: { workosUserId: claims.sub },
            select: { id: true, role: true, companyId: true } // Select only necessary fields
        });

        // --- UPDATED ROLE-BASED AUTHORIZATION ---
        // 3. Role-based Authorization: Now allows 'sr executive', 'executive', and 'jr executive' to add dealers
        if (!currentUser || !allowedRoles.includes(currentUser.role)) {
            return NextResponse.json({ error: `Forbidden: Only the following roles can add dealers: ${allowedRoles.join(', ')}` }, { status: 403 });
        }

        const body = await request.json();
        const parsedBody = postDealerSchema.safeParse(body); // Use postDealerSchema for POST validation

        if (!parsedBody.success) {
            console.error('Add Dealer Validation Error (POST):', parsedBody.error.format());
            return NextResponse.json({ message: 'Invalid request body', errors: parsedBody.error.format() }, { status: 400 });
        }

        const {
            name,
            type,
            region,
            area,
            phoneNo,
            address,
            totalPotential,
            bestPotential,
            brandSelling,
            feedbacks,
            remarks,
        } = parsedBody.data;

        // Geocoding API call to OpenCage Geocoding service
        let latitude = null;
        let longitude = null;
        let formattedAddress = address; // Default to the original address
        const apiKey = process.env.OPENCAGE_GEO_API; // <--- YOU MUST REPLACE THIS

        // Build the URL for the geocoding request
        const openCageApiUrl = `https://api.opencagedata.com/geocode/v1/json?q=${encodeURIComponent(address)}&key=${apiKey}`;
        console.log('OpenCage API URL:', openCageApiUrl);

        try {
            const geocodeResponse = await fetch(openCageApiUrl);
            
            //console.log('OpenCage API response status:', geocodeResponse.status);

            if (geocodeResponse.ok) {
                const geocodeResults = await geocodeResponse.json();
                //console.log('Geocoding results:', geocodeResults);

                if (geocodeResults.results.length > 0) {
                    latitude = geocodeResults.results[0].geometry.lat;
                    longitude = geocodeResults.results[0].geometry.lng;
                    formattedAddress = `${geocodeResults.results[0]} || ${latitude},${longitude}`;
                    console.log('Successfully geocoded. Formatted address:', formattedAddress);
                } else {
                    //console.warn('Geocoding failed: OpenCage returned no results.');
                }
            } else {
                //console.error('Geocoding failed. HTTP Status:', geocodeResponse.status);
                try {
                  const errorText = await geocodeResponse.text();
                  console.error('Geocoding Error Body:', errorText);
                } catch (e) {
                  console.error('Could not parse error body:', e);
                }
            }
        } catch (geocodeError) {
            console.error('An error occurred during geocoding:', geocodeError);
            console.warn('Geocoding failed, storing address without coordinates.');
        }
        // End of Geocoding section

        // Create the new dealer in the database
        const newDealer = await prisma.dealer.create({
            data: {
                userId: currentUser.id, // Associate the dealer with the current admin/manager
                name: name,
                type: type,
                region: region,
                area: area,
                phoneNo: phoneNo,
                address: formattedAddress, //Address stored with Lat and Lon using || separator
                totalPotential: totalPotential,
                bestPotential: bestPotential,
                brandSelling: brandSelling,
                feedbacks: feedbacks,
                remarks: remarks,
            },
        });

        return NextResponse.json({ message: 'Dealer added successfully!', dealer: newDealer }, { status: 201 });
    } catch (error) {
        console.error('Error adding dealer (POST):', error);
        return NextResponse.json({ error: 'Failed to add dealer', details: (error as Error).message }, { status: 500 });
    } finally {
        await prisma.$disconnect(); // Disconnect Prisma client
    }
}

export async function GET() {
    try {
        const claims = await getTokenClaims();

        // 1. Authentication Check
        if (!claims || !claims.sub) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        // 2. Fetch Current User to get their ID and role
        const currentUser = await prisma.user.findUnique({
            where: { workosUserId: claims.sub },
            select: { id: true, role: true, companyId: true } // Select only necessary fields
        });

        // 3. Role-based Authorization: Now allows 'sr executive', 'executive', and 'jr executive' to add dealers
        if (!currentUser || !allowedRoles.includes(currentUser.role)) {
            return NextResponse.json({ error: `Forbidden: Only the following roles can add dealers: ${allowedRoles.join(', ')}` }, { status: 403 });
        }

        // 4. Fetch Dealers for the current user's company
        const dealers = await prisma.dealer.findMany({
            where: {
                user: { // Filter dealers by the company of the user who created them
                    companyId: currentUser.companyId,
                },
            },
            orderBy: {
                createdAt: 'desc', // Order by latest added dealers first
            },
            take: 200, // Limit to recent dealers for dashboard view
        });

        // 5. Format the data to match the getDealerResponseSchema for the frontend
        const formattedDealers = dealers.map(dealer => ({
            id: dealer.id,
            name: dealer.name,
            type: dealer.type,
            region: dealer.region,
            area: dealer.area,
            phoneNo: dealer.phoneNo,
            address: dealer.address,
            totalPotential: dealer.totalPotential.toNumber(),
            bestPotential: dealer.bestPotential.toNumber(),
            brandSelling: dealer.brandSelling,
            feedbacks: dealer.feedbacks,
            remarks: dealer.remarks,
            createdAt: dealer.createdAt.toISOString(),
            updatedAt: dealer.updatedAt.toISOString(),
        }));

        // 6. Validate the formatted data against the getDealerResponseSchema
        const validatedDealers = z.array(getDealerResponseSchema).parse(formattedDealers); // Use the new GET schema

        return NextResponse.json(validatedDealers, { status: 200 });
    } catch (error) {
        console.error('Error fetching dealers (GET):', error);
        return NextResponse.json({ error: 'Failed to fetch dealers', details: (error as Error).message }, { status: 500 });
    } finally {
        //await prisma.$disconnect(); // Disconnect Prisma client
    }
}

// DELETE function to remove a dealer
export async function DELETE(request: NextRequest) {
    try {
        const claims = await getTokenClaims();

        // 1. Authentication Check
        if (!claims || !claims.sub) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        // 2. Fetch Current User to get their ID and role
        const currentUser = await prisma.user.findUnique({
            where: { workosUserId: claims.sub },
            select: { id: true, role: true, companyId: true }
        });

        // 3. Role-based Authorization
        if (!currentUser || !allowedRoles.includes(currentUser.role)) {
            return NextResponse.json({ error: `Forbidden: Only the following roles can delete dealers: ${allowedRoles.join(', ')}` }, { status: 403 });
        }

        // 4. Extract dealerId from the query parameters
        const url = new URL(request.url);
        const dealerId = url.searchParams.get('id');

        if (!dealerId) {
            return NextResponse.json({ error: 'Missing dealer ID in request' }, { status: 400 });
        }

        // 5. Verify the dealer exists and belongs to the current user's company
        const dealerToDelete = await prisma.dealer.findUnique({
            where: { id: dealerId },
            include: { user: true }
        });

        if (!dealerToDelete) {
            return NextResponse.json({ error: 'Dealer not found' }, { status: 404 });
        }

        if (dealerToDelete.user.companyId !== currentUser.companyId) {
            return NextResponse.json({ error: 'Forbidden: Cannot delete a dealer from another company' }, { status: 403 });
        }

        // 6. Delete the dealer from the database
        await prisma.dealer.delete({
            where: { id: dealerId }
        });

        return NextResponse.json({ message: 'Dealer deleted successfully' }, { status: 200 });

    } catch (error) {
        console.error('Error deleting dealer (DELETE):', error);
        return NextResponse.json({ error: 'Failed to delete dealer', details: (error as Error).message }, { status: 500 });
    } finally {
        await prisma.$disconnect();
    }
}